<!DOCTYPE html>
<html lang="fr">
<head>
  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#2a66c7">

  <!-- iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Traceur Rando">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

<meta charset="utf-8">
<title>Traceur randonn√©e dev_menu_6.6.4.1 mobile - IBP - thunderforest (rev)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Leaflet / libs -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- togeojson (conversion GPX -> GeoJSON) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
<!-- togpx pour export GPX -->
<script src="https://unpkg.com/togpx@0.5.0/togpx.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>

<style>
  :root{
    --dock-bottom: 14px;
    --dock-bg: rgba(0,0,0,0.10);
    --btn-bg: rgba(0,0,0,0.35);
    --accent: #2a66c7;
  }
  html,body { height:100%; margin:0; font-family:Arial,Helvetica,sans-serif; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  #map { height: 100vh; width:100%; }
  body { overflow-x:hidden; }
  /* Top bar (search + import) */
  .top-bar{
    position: fixed;
    top: calc(6px + env(safe-area-inset-top));
    left: 50%;
    transform: translateX(-50%);
    display:flex;
    gap:8px;
    z-index:1400;
    padding:6px 10px;
    border-radius:20px;
    align-items:center;
    pointer-events:auto;
  }
  .top-bar input[type="text"], .top-bar input[type="search"]{ padding:6px 10px; border-radius:12px; border: none; height:34px; width:160px; }
  .file-pill { display:inline-flex; align-items:center; gap:8px; border-radius:12px; padding:6px 8px; 
  background:transparent !important; height:34px; }
  .file-pill button { border:none; background:var(--accent); color:white; padding:6px 10px; border-radius:8px; cursor:pointer; }

  /* Dock (bottom) safe area aware */
  .leaflet-control.custom-panel{
    position: fixed !important;
    bottom: calc(var(--dock-bottom) + env(safe-area-inset-bottom));
    left: 50%;
    transform: translateX(-50%);
    z-index:1500;
    pointer-events:auto;
    background: transparent !important;
    border:none !important;
    box-shadow:none !important;
    padding: 0;
    width: auto;
  }
  .icon-grid { display:flex; gap:8px; padding:6px; background: var(--dock-bg); border-radius:28px; align-items:center; }
  .icon-btn{ width:36px; height:36px; border-radius:50%; border:none; background:var(--btn-bg); color:#fff; font-size:16px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.25); }
  .icon-btn.secondary{ background: rgba(0,0,0,0.22); }
  .icon-btn.recording{ background: rgba(180,0,0,0.6); animation: pulse 1.2s infinite; }
  @keyframes pulse{ 0%{transform:scale(1);}50%{transform:scale(1.08);}100%{transform:scale(1);} }

  /* ensure dock not flush to bottom on older iOS */
  @supports (padding: env(safe-area-inset-bottom)) {
    .leaflet-control.custom-panel { padding-bottom: calc(env(safe-area-inset-bottom)); }
  }

  /* Info panel */
.container{
  position: fixed;
  bottom: calc(0px + env(safe-area-inset-bottom));
  left:0;
  width:100%;
  height:260px;
  background:#111;
  color:#fff;
  z-index:1400;
  overflow:auto;
  padding:10px;
  box-sizing:border-box;
  transition: transform 0.28s ease;
}

/* √©tat par d√©faut = ferm√© mais poign√©e visible */
.container.closed{
  transform: translateY(calc(100% - 28px));
}

.container.open{
  transform: translateY(0%);
}


  .info-toggle { position: fixed; bottom: calc(60px + env(safe-area-inset-bottom)); left:10px; z-index:1500; background:var(--accent); color:white; border:none; border-radius:20px; padding:8px 14px; cursor:pointer; }

  /* ==== POIGN√âE DU PANNEAU INFOS ==== */

.info-handle{
  width: 42px;
  height: 5px;
  border-radius: 3px;
  background: rgba(42,102,199,0.9);
  margin: 6px auto 10px auto;
  cursor: pointer;
  box-shadow: 0 0 6px rgba(42,102,199,0.6);
}

  /* small screens */
  @media (max-width:420px){
    .top-bar input[type="search"]{ width:120px; font-size:13px; }
    .icon-btn{ width:30px; height:30px; font-size:14px; }
  }

  .tooltip-mobile{ position:absolute; background:rgba(0,0,0,0.85); color:#fff; padding:6px 8px; border-radius:6px; font-size:12px; z-index:2000; display:none; pointer-events:none; }

  /* searchResults */
  #searchResults{ position:absolute; top:48px; left:50%; transform:translateX(-50%); width:320px; max-width:calc(100% - 20px); background:#fff; color:#111; box-shadow:0 6px 18px rgba(0,0,0,0.12); border-radius:8px; z-index:3000; display:none; max-height:260px; overflow:auto; }

  /* small cosmetics for import feedback */
  #importStatus{ font-size:13px; color:#333; margin-left:8px; }

  /* make map full height when content hidden */
  body.fullscreen #map { height:100vh; }

  /* keep touch interactions nice on leaflet */
  .leaflet-container { touch-action: pan-x pan-y; -webkit-touch-callout: none; }

/* ==== DOCK AMOVIBLE (BOTTOM DRAWER) ==== */

.leaflet-control.custom-panel{
  transition: transform 0.28s ease;
  touch-action: pan-y;
}

/* poign√©e toujours visible */
.dock-handle{
  width: 48px;                 /* plus large */
  height: 6px;                 /* plus √©pais */
  border-radius: 4px;
  background: #c7302a;         /* ROUGE */
  margin: 8px auto 10px auto;
  box-shadow: 
    0 0 8px rgba(199,48,42,0.9),
    0 0 14px rgba(199,48,42,0.6); /* glow visible */
}
.leaflet-control.custom-panel.closed .dock-handle{
  box-shadow:
    0 0 12px rgba(199,48,42,1),
    0 0 20px rgba(199,48,42,0.9);
}

/* dock ferm√© ‚Üí descend MAIS garde la poign√©e visible */
.leaflet-control.custom-panel.closed{
  transform: translateX(-50%) translateY(48px);
}


</style>
</head>
<body>

  <div id="map"></div>

  <!-- STARTUP POPUP -->
  <div id="startupPopup" style="position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:5000;font-family:Arial;">
    <div style="background:#fff;padding:18px;border-radius:12px;max-width:340px;text-align:left;box-shadow:0 6px 20px rgba(0,0,0,0.25);">
      <h3 style="margin:0 0 6px 0;">üëã Bienvenue</h3>
      <p style="margin:0 0 8px 0;font-size:13px;color:#333;">Version 6.6.4.1. Menus Boutons et Infos amovibles avec diff√©renciation des poign√©es. Activez le GPS pour un suivi optimal. Si les GPX semblent non reconnus sur mobile, utilisez le bouton ‚ÄúImporter GPX‚Äù.</p>
      <div style="text-align:right"><button onclick="closeStartupPopup()" style="background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;">OK</button></div>
    </div>
  </div>

  <!-- TOP BAR: recherche + import -->
  <div class="top-bar" role="region" aria-label="recherche et import gpx">
    <input id="searchInput" type="search" placeholder="üîç Rechercher un lieu" aria-label="Rechercher un lieu">
    <!-- visible tactile import button -->
    <div class="file-pill" role="button" aria-label="Importer GPX">
      <span></span>
      <button id="openFileBtn" title="Importer GPX">Importer GPX</button>
      <span id="importStatus" aria-live="polite"></span>
    </div>
    <!-- hidden actual file input (import de tous gpx)-->
    <input 
  type="file" 
  id="importFile" 
  accept=".gpx,application/gpx+xml,application/xml,text/xml,application/octet-stream"
style="display:none;"
  aria-hidden="true"
  />

  </div>

  <div id="searchResults"></div>

  <!-- info panel -->
  <div class="container" aria-live="polite">
    <!-- POIGN√âE DU PANNEAU INFOS (√Ä AJOUTER ICI) -->
  <div class="info-handle" aria-label="Ouvrir / fermer les infos"></div>

    <div id="distance"></div>
    <canvas id="elevationChart" style="width:100%;height:160px;"></canvas>
    <form id="formuploadajax" enctype="multipart/form-data" style="display:none;">
      <input type="hidden" name="key" value="ifwh7wlwykzixzxcg6rb">
      <input type="hidden" name="type" value="hiking">
      <input type="file" id="ibpFile" name="file" accept=".gpx">
    </form>
    <div id="obtain"></div>
  </div>

  <div id="mobileTooltip" class="tooltip-mobile"></div>

<script>
/* --------------------- CONFIG / CONST --------------------- */
const ORS_KEY = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImI4YjFjZDdiMTkyZWZmYTc0N2IyNjQ3MWMxNWJkYzAwMWNiMjI1NGZjNmYyMTI5MDgwN2ZmYzgyIiwiaCI6Im11cm11cjY0In0=";
const ORS_URL = "https://api.openrouteservice.org/v2/directions/foot-hiking/geojson";

/* --------------------- CARTE / LAYERS --------------------- */
const map = L.map('map').setView([46.8,2.2],6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

let markers = L.layerGroup().addTo(map);
let routeLayer = L.layerGroup().addTo(map);
let straightLineLayer = L.layerGroup().addTo(map);
let editableMarkers = L.layerGroup().addTo(map); // pour √©dition
let editPointsLayer = L.layerGroup().addTo(map); // points √©ditables visibles
let manualPoints = [];          // points (lng,lat) pass√©s √† ORS multi-points
let manualRouteCoords = [];     // [ [lat,lng,ele], ... ] : trace calcul√©e / import√©e

let A=null,B=null, markerA=null, markerB=null, straightLine=null;

/* thunderforest / hiking layers (pr√©serv√©s) */
const thunderforestTrails = L.tileLayer("https://tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey=0ffff5950d8a4019bcede9aaeeecb57f",{ maxZoom:22, attribution:"Maps ¬© Thunderforest, Data ¬© OSM" });
const hikingTrailsLayer = L.tileLayer("https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png",{ maxZoom:18, opacity:0.9, attribution:"¬© Waymarked Trails / OSM" });

/* panel bottom */
const panel = L.control({ position: 'bottomleft' });
panel.onAdd = function(){
  const div = L.DomUtil.create('div','leaflet-control custom-panel');
div.innerHTML = `
  <div class="dock-wrapper">
  <div class="dock-handle" aria-label="Ouvrir le menu"></div>
  <div class="icon-grid" role="toolbar" aria-label="menu actions">


    <button class="icon-btn" onclick="searchLocation()" title="Rechercher">üîç</button>
    <button class="icon-btn" onclick="setPointA()" title="Point A">üÖ∞Ô∏è</button>
    <button class="icon-btn" onclick="setPointB()" title="Point B">üÖ±Ô∏è</button>
    <button class="icon-btn" onclick="drawStraightLine()" title="Ligne A‚ÜíB">üìè</button>
    <button class="icon-btn secondary" onclick="removeLastPoint()" title="Annuler dernier point">‚Ü©Ô∏è</button>
    <button class="icon-btn secondary" onclick="clearAll()" title="Effacer tout">üóëÔ∏è</button>
    <button class="icon-btn" onclick="exportGPX()" title="Exporter GPX">üíæ</button>
    <button class="icon-btn" onclick="toggleInfoPanel()" title="Infos">üìä</button>
    <button class="icon-btn" onclick="centerGPS()" title="Recentrer GPS">üìç</button>
    <button class="icon-btn" id="recBtn" onclick="toggleAutoRecording()" title="Enregistrement GPS">‚ñ∂Ô∏è</button>
  </div>
  </div>
`;

  L.DomEvent.disableClickPropagation(div);
  L.DomEvent.disableScrollPropagation(div);

  return div;
};
panel.addTo(map);

/* layers control */
const baseLayers = {
  "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'),
  "Thunderforest Outdoors": thunderforestTrails
};
const overlays = {
  "Sentiers hiking (Waymarked Trails)": hikingTrailsLayer,
  "Points manuels": markers,
  "Ligne droite A‚ÜíB": straightLineLayer,
  "Trace ORS": routeLayer
};
L.control.layers(baseLayers, overlays, { collapsed:true, position:"topright" }).addTo(map);

/* --------------------- GPS (pointeur) --------------------- */
let gpsMarker = null;
if(navigator.geolocation){
  navigator.geolocation.watchPosition(pos=>{
    const latlng=[pos.coords.latitude, pos.coords.longitude];
    const redIcon = L.icon({ iconUrl:"https://upload.wikimedia.org/wikipedia/commons/e/ec/RedDot.svg", iconSize:[14,14], iconAnchor:[7,7] });
    if(!gpsMarker){ gpsMarker = L.marker(latlng,{icon:redIcon}).addTo(map); map.setView(latlng,12); } else gpsMarker.setLatLng(latlng);
  }, err=>console.warn("GPS:",err), { enableHighAccuracy:true });
}

/* --------------------- UTILS ELEVATION & DISTANCE --------------------- */
function smoothArray(data, alpha=0.22){
  if(!data.length) return data;
  const out=new Array(data.length); out[0]=data[0];
  for(let i=1;i<data.length;i++) out[i]=out[i-1]*(1-alpha)+data[i]*alpha;
  out[out.length-1]=data[data.length-1];
  return out;
}
function computeElevationGain(elev){
  let up=0,down=0;
  for(let i=1;i<elev.length;i++){ const d=elev[i]-elev[i-1]; if(d>0) up+=d; else down+=Math.abs(d); }
  return {positive:Math.round(up), negative:Math.round(down)};
}
function computeMinMax(elev){ if(!elev.length) return {min:0,max:0}; return {min:Math.round(Math.min(...elev)), max:Math.round(Math.max(...elev))}; }
function computeTotalDistanceLatLngs(latlngs){ if(!latlngs.length) return 0; let tot=0; for(let i=1;i<latlngs.length;i++) tot+=L.latLng(latlngs[i-1][0],latlngs[i-1][1]).distanceTo(L.latLng(latlngs[i][0],latlngs[i][1])); return tot; }
function computeCumulativeDistances(latlngs){ let arr=[0], tot=0; for(let i=1;i<latlngs.length;i++){ tot+=L.latLng(latlngs[i-1][0],latlngs[i-1][1]).distanceTo(L.latLng(latlngs[i][0],latlngs[i][1])); arr.push((tot/1000).toFixed(3)); } return arr; }

/* --------------------- ELEVATION CHART --------------------- */
let elevationChart = null;
function drawElevation(elevations, latlngs=[]){
  const smooth = elevations && elevations.length ? smoothArray(elevations.map(e=>Math.round(e||0)), 0.22) : [];
  const gain = computeElevationGain(smooth);
  const mm = computeMinMax(smooth);
  const cumulative = latlngs.length ? computeCumulativeDistances(latlngs) : smooth.map((_,i)=>i);
  const ctx = document.getElementById('elevationChart').getContext('2d');
  if(elevationChart) elevationChart.destroy();
  elevationChart = new Chart(ctx, {
    type:'line',
    data:{ labels:cumulative, datasets:[{ label:'Altitude (m)', data:smooth, borderWidth:2, fill:false, tension:0.25, pointRadius:0 }]},
    options:{ responsive:true, maintainAspectRatio:false, scales:{ x:{ title:{display:true,text:"Distance (km)"}}, y:{ title:{display:true,text:"Altitude (m)"} } } }
  });
  const totalDistance = latlngs.length ? (computeTotalDistanceLatLngs(latlngs)/1000).toFixed(2) : "0.00";
  document.getElementById('distance').innerHTML = `üìè <b>Distance totale :</b> ${totalDistance} km<br>‚¨ÜÔ∏è <b>D+ :</b> ${gain.positive} m &nbsp; ‚¨áÔ∏è <b>D- :</b> ${gain.negative} m<br>üîª <b>Min :</b> ${mm.min} m | üî∫ <b>Max :</b> ${mm.max} m`;
}

/* --------------------- ORS: rebuild route from manualPoints (multipoints) --------------------- */
let orsRequestInProgress = false;   // ‚Üê MODIF A √Ä AJOUTER ICI
async function rebuildManualRouteFromPoints(){

  // ===== MODIF B : VERROU ORS =====
  if (orsRequestInProgress) return;
  orsRequestInProgress = true;
  // ===============================

  routeLayer.clearLayers();
  editableMarkers.clearLayers();
  editPointsLayer.clearLayers();
  manualRouteCoords = [];

  if(manualPoints.length < 2){
    orsRequestInProgress = false;   // ‚Üê IMPORTANT
    drawElevation([],[]);
    saveRouteLocal();
    return;
  }

  try{
    const res = await fetch(ORS_URL, {
      method:"POST",
      headers: { "Authorization": ORS_KEY, "Content-Type":"application/json" },
      body: JSON.stringify({ coordinates: manualPoints, elevation:true, instructions:false, preference:"recommended" })
    });
    if(!res.ok) throw new Error("ORS HTTP " + res.status);
    const data = await res.json();
    if(!data.features || !data.features.length) throw new Error("ORS: pas de g√©om√©trie");

    const coords = data.features[0].geometry.coordinates;
    coords.forEach(c => manualRouteCoords.push([c[1], c[0], c[2] || 0]));
    const latlngs = manualRouteCoords.map(c=>[c[0],c[1]]);
    L.polyline(latlngs, { color:"green", weight:4, smoothFactor:1.2 }).addTo(routeLayer);

    // cr√©ation de markers √©ditables
    createEditableMarkersFromCoords(latlngs);

    drawElevation(manualRouteCoords.map(c=>c[2]||0), latlngs);
    refreshMarkers(); // met √† jour les points manuels si pr√©sents
    saveRouteLocal();
  } catch(err){
  console.error("Erreur ORS multipoints:", err);
} finally {
  orsRequestInProgress = false;   // ‚Üê LIB√àRE LE VERROU
}

}

/* --------------------- MAP CLICK POUR AJOUTER POINTS --------------------- */
map.on('click', e => {
  manualPoints.push([e.latlng.lng, e.latlng.lat]);
  rebuildManualRouteFromPoints();
});

/* --------------------- A/B / Ligne droite --------------------- */
function setPointA(){
  map.once('click', e => {
    A = e.latlng;
    if(markerA) straightLineLayer.removeLayer(markerA);
    markerA = L.marker(A).addTo(straightLineLayer).bindPopup("A").openPopup();
  });
}
function setPointB(){
  map.once('click', e => {
    B = e.latlng;
    if(markerB) straightLineLayer.removeLayer(markerB);
    markerB = L.marker(B).addTo(straightLineLayer).bindPopup("B").openPopup();
  });
}
function drawStraightLine(){
  if(!A || !B) return alert("D√©finissez A et B avant de tracer la ligne droite.");
  if(straightLine) straightLineLayer.removeLayer(straightLine);
  straightLine = L.polyline([[A.lat,A.lng],[B.lat,B.lng]], { color:"red", weight:3, dashArray:"6,6" }).addTo(straightLineLayer);
  const dist = A.distanceTo(B)/1000;
  const prev = document.getElementById('distance').innerHTML || "";
  document.getElementById('distance').innerHTML = `üìè Ligne droite A‚ÜíB : <b>${dist.toFixed(2)} km</b><br>` + prev;
  map.fitBounds(L.latLngBounds([A,B]).pad(0.2));
}

/* --------------------- ORS A->B --------------------- */
async function computeRoute(){
  if(!A || !B) return alert("D√©finissez A et B pour calculer le trac√© r√©el ORS entre eux.");
  try{
    const res = await fetch(ORS_URL, {
      method:"POST",
      headers: { "Authorization": ORS_KEY, "Content-Type":"application/json" },
      body: JSON.stringify({ coordinates: [[A.lng,A.lat],[B.lng,B.lat]], elevation:true, instructions:false })
    });
    if(!res.ok) throw new Error("ORS HTTP " + res.status);
    const data = await res.json();
    const coords = data.features[0].geometry.coordinates.map(c=>[c[1],c[0]]);
    const elev = data.features[0].geometry.coordinates.map(c=>c[2]||0);
    routeLayer.clearLayers();
    L.polyline(coords, { color:"blue", weight:4 }).addTo(routeLayer);
    // save route
    manualRouteCoords = coords.map((c,i)=>[c[0],c[1],elev[i]||0]);
    createEditableMarkersFromCoords(coords);
    drawElevation(elev, coords);
    saveRouteLocal();
    map.fitBounds(coords);
  } catch(err){ console.error("Erreur computeRoute:",err); alert("Erreur ORS computeRoute."); }
}

/* --------------------- IMPORT GPX (robuste, mobile fallback) --------------------- */

/**
 * readFileText(file) -> Promise<string>
 * - utilise file.text() si disponible
 * - sinon fallback FileReader
 */
function readFileText(file){
  return new Promise((resolve, reject) => {
    if(file.text){
      file.text().then(resolve).catch(() => {
        // fallback
        const fr=new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = e => reject(e);
        fr.readAsText(file);
      });
    } else {
      const fr=new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = e => reject(e);
      fr.readAsText(file);
    }
  });
}

/* safe conversion GPX -> GeoJSON using available lib */
function convertGpxToGeoJSONFromXml(xmlDoc){
  // try typical global names (togeojson or toGeoJSON)
  if(window.toGeoJSON && typeof window.toGeoJSON.gpx === "function"){
    return window.toGeoJSON.gpx(xmlDoc);
  }
  if(window.togeojson && typeof window.togeojson.gpx === "function"){
    return window.togeojson.gpx(xmlDoc);
  }
  if(window.TO_GPX && typeof window.TO_GPX === "function"){
    // improbable, fallback placeholder
    return window.TO_GPX(xmlDoc);
  }
  throw new Error("Lib toGeoJSON introuvable");
}

/******************************************************************
 *   IMPORT GPX ‚Äî VERSION VALID√âE ET COMPL√àTE
 ******************************************************************/
async function handleFileImport(file){
  if(!file) return;

  let geojson = null;
  const statusEl = document.getElementById('importStatus');

  try {
    statusEl.textContent = 'import en cours...';

    const text = await readFileText(file);

    const isProbablyGPX =
      (file.name && file.name.toLowerCase().endsWith(".gpx")) ||
      (typeof text === "string" && (
        text.trim().startsWith("<gpx") ||
        text.includes("<trk") ||
        text.includes("<trkpt")
      ));

    if(isProbablyGPX){
      const xml = new DOMParser().parseFromString(text, "text/xml");
      geojson = convertGpxToGeoJSONFromXml(xml);
    } else {
      geojson = JSON.parse(text);
    }

    if(!geojson || !geojson.features || !geojson.features.length){
      statusEl.textContent = 'Aucune trace trouv√©e';
      alert("Aucune trace exploitable trouv√©e.");
      return;
    }

    // Reset
    manualPoints = [];
    manualRouteCoords = [];
    routeLayer.clearLayers();
    markers.clearLayers();
    editableMarkers.clearLayers();

    let coords = [];

    geojson.features.forEach(f=>{
      if(!f.geometry) return;
      if(f.geometry.type === "LineString") coords.push(...f.geometry.coordinates);
      if(f.geometry.type === "MultiLineString")
        f.geometry.coordinates.forEach(seg=>coords.push(...seg));
      if(f.geometry.type === "Point") coords.push(f.geometry.coordinates);
    });

    if(!coords.length){
      statusEl.textContent = 'Aucune trace trouv√©e';
      alert("Trace non lisible.");
      return;
    }

    coords.forEach(c=>{
      if(c.length >= 2){
        manualRouteCoords.push([ c[1], c[0], c[2] || 0 ]);
      }
    });

    const latlngs = manualRouteCoords.map(c=>[c[0],c[1]]);

    routeLayer.clearLayers();
    L.polyline(latlngs, { color:"red", weight:4 }).addTo(routeLayer);

    createEditableMarkersFromCoords(latlngs);
    map.fitBounds(latlngs, { padding:[20,20] });
    drawElevation(manualRouteCoords.map(c=>c[2]||0), latlngs);

    manualPoints = [];

    statusEl.textContent = 'Import OK';
    setTimeout(()=> statusEl.textContent = '', 1800);

  } catch(err){
    console.error("Erreur import GPX:", err);
    statusEl.textContent = 'Erreur import';
    alert("Erreur durant l'import : " + err.message);
  }
}



/* wire hidden file input + visible button */
const importFileInput = document.getElementById('importFile');
const openFileBtn = document.getElementById('openFileBtn');
openFileBtn.addEventListener('click', () => {
  // reset to allow re-import same file
  importFileInput.value = '';
  importFileInput.click();
});
// on change -> process file
importFileInput.addEventListener('change', (evt) => {
  const file = evt.target.files && evt.target.files[0];
  if(file) handleFileImport(file);
});

/* optional: drag/drop for desktop */
document.addEventListener('dragover', (e)=>{ e.preventDefault(); });
document.addEventListener('drop', (e)=>{ e.preventDefault(); if(e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length){ handleFileImport(e.dataTransfer.files[0]); } });

/* --------------------- EXPORT GPX / GEOJSON --------------------- */
function exportGeoJSON(){
  if(!manualRouteCoords.length) return alert("Aucune trace √† exporter");
  const geo = { type:"FeatureCollection", features:[{ type:"Feature", geometry:{ type:"LineString", coordinates: manualRouteCoords.map(c=>[c[1],c[0],c[2]||0]) }, properties:{} }]};
  const blob = new Blob([JSON.stringify(geo)],{ type:"application/json" });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "trace.geojson"; a.click();
}

function exportGPX(){
  if(manualRouteCoords.length < 2) return alert("Aucune trace compl√®te √† exporter");
  const geo = { type:"FeatureCollection", features:[{ type:"Feature", geometry:{ type:"LineString", coordinates: manualRouteCoords.map(c=>[c[1],c[0],c[2]||0]) }, properties:{ name:"Trace compl√®te ORS" } }]};
  const gpx = togpx(geo);
  const blob = new Blob([gpx], { type:"application/gpx+xml" });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "trace_complete.gpx"; a.click();

  // injection IBP (conserve le comportement existant)
  try {
    const file = new File([blob],"trace_complete.gpx",{ type:"application/gpx+xml" });
    const dt = new DataTransfer(); dt.items.add(file);
    document.getElementById('ibpFile').files = dt.files;
    document.getElementById('formuploadajax').dispatchEvent(new Event('submit', { bubbles:true, cancelable:true }));
    document.getElementById('obtain').innerHTML = "‚è≥ Calcul IBP en cours (GPX COMPLET envoy√©)...";
  } catch(err){ console.error("Erreur injection IBP:", err); }
}

/* --------------------- refresh / markers / √©dition --------------------- */
function refreshMarkers(){
  markers.clearLayers();
  manualPoints.forEach((p, idx) => {
    const m = L.circleMarker([p[1], p[0]], { radius:4, color:null, weight:0, fillColor:"#c7302a", fillOpacity:0.9 })}).addTo(editPointsLayer);
    m.on('contextmenu', () => { manualPoints.splice(idx,1); rebuildManualRouteFromPoints(); refreshMarkers(); });
  };

function removeLastPoint(){ if(!manualPoints.length) return; manualPoints.pop(); rebuildManualRouteFromPoints(); refreshMarkers(); }
function clearAll(){
  manualPoints=[]; manualRouteCoords=[]; routeLayer.clearLayers(); markers.clearLayers(); editableMarkers.clearLayers();editPointsLayer.clearLayers();   // ‚Üê AJOUT ICI
  if(markerA){ straightLineLayer.removeLayer(markerA); markerA=null; A=null; }
  if(markerB){ straightLineLayer.removeLayer(markerB); markerB=null; B=null; }
  if(straightLine){ straightLineLayer.removeLayer(straightLine); straightLine=null; }
  document.getElementById('distance').innerHTML = "";
  if(elevationChart) elevationChart.destroy();
  clearSavedRoute();
}

/* create draggable markers for editing a route (latlngs: [[lat,lng],...]) */
/*function createEditableMarkersFromCoords(latlngs){
  editableMarkers.clearLayers();
  latlngs.forEach((ll, idx) => {
    const mk = L.circleMarker([ll[0], ll[1]], { radius:4, color:null, fillColor:"#c7302a", fillOpacity:0.95 }).addTo(editableMarkers);
    mk.options.draggable = true; // not native draggable for circleMarker -> use drag behavior hack via marker
    const proxy = L.marker([ll[0],ll[1]], { opacity:0, draggable:true }).addTo(editableMarkers);
    proxy.on('drag', (e) => {
      mk.setLatLng(e.target.getLatLng());
    });
    proxy.on('dragend', (e) => {
      const newLatLng = e.target.getLatLng();
      // update manualRouteCoords at index
      if(manualRouteCoords[idx]) manualRouteCoords[idx][0] = newLatLng.lat, manualRouteCoords[idx][1] = newLatLng.lng;
      // redraw polyline
      routeLayer.clearLayers();
      const latlngsNow = manualRouteCoords.map(c=>[c[0],c[1]]);
      L.polyline(latlngsNow, { color:"green", weight:4 }).addTo(routeLayer);
      drawElevation(manualRouteCoords.map(c=>c[2]||0), latlngsNow);
      saveRouteLocal();
    });
  });
}*/
function createEditableMarkersFromCoords(latlngs){
  editableMarkers.clearLayers();

  latlngs.forEach((ll, idx) => {

    // --- POINT EDITABLE VISUEL (dans la couche "Points manuels") ---
    const mk = L.circleMarker([ll[0], ll[1]], {
      radius:4,
      color:null,
      weight:0,
      fillColor:"#2a66c7",
      fillOpacity:1
    }).addTo(markers);   // <-- IMPORTANT : dans markers, donc supprimable/masquable


    // --- PROXY DRAG INVISIBLE (reste dans editableMarkers) ---
    const proxy = L.marker([ll[0], ll[1]], {
      opacity:0,
      draggable:true
    }).addTo(editableMarkers);

    // sync visible point during drag
    proxy.on('drag', (e) => {
      mk.setLatLng(e.target.getLatLng());
    });

    // update route after drag end
    proxy.on('dragend', (e) => {
      const newLatLng = e.target.getLatLng();

      // update the coords in the main route array
      if (manualRouteCoords[idx]) {
        manualRouteCoords[idx][0] = newLatLng.lat;
        manualRouteCoords[idx][1] = newLatLng.lng;
      }

      // redraw polyline
      routeLayer.clearLayers();
      const latlngsNow = manualRouteCoords.map(c => [c[0], c[1]]);
      L.polyline(latlngsNow, { color:"green", weight:4 }).addTo(routeLayer);

      // redraw elevation profile
      drawElevation(
        manualRouteCoords.map(c => c[2] || 0),
        latlngsNow
      );

      // save local
      saveRouteLocal();
    });

  });
}

/* --------------------- RECORDING GPS --------------------- */
let gpsTracking=false, recordedTrace=[];
function toggleAutoRecording(){
  gpsTracking = !gpsTracking;
  const btn = document.getElementById('recBtn');
  if(!btn) return;
  if(gpsTracking){ recordedTrace=[]; btn.classList.add('recording'); btn.innerHTML='‚èπÔ∏è'; showTooltip("Enregistrement GPS d√©marr√©"); }
  else {
    btn.classList.remove('recording'); btn.innerHTML='‚ñ∂Ô∏è';
    if(recordedTrace.length>2){
      manualRouteCoords = recordedTrace.map(p=>[p.lat,p.lng,p.ele||0]);
      routeLayer.clearLayers();
      L.polyline(recordedTrace.map(p=>[p.lat,p.lng]),{color:"green",weight:4}).addTo(routeLayer);
      createEditableMarkersFromCoords(recordedTrace.map(p=>[p.lat,p.lng]));
      drawElevation(recordedTrace.map(p=>p.ele||0), recordedTrace.map(p=>[p.lat,p.lng]));
      saveRouteLocal();
    }
    showTooltip("Enregistrement GPS arr√™t√©");
  }
}
if(navigator.geolocation){
  navigator.geolocation.watchPosition(p=>{
    if(gpsTracking) recordedTrace.push({ lat:p.coords.latitude, lng:p.coords.longitude, ele:p.coords.altitude||0 });
  }, err=>{}, { enableHighAccuracy:true });
}

/* --------------------- SEARCH (Nominatim) --------------------- */
let searchMarkerGroup = L.layerGroup().addTo(map);
async function searchLocation(){
  const q = document.getElementById('searchInput').value.trim();
  const resultsDiv = document.getElementById('searchResults');
  if(!q){ resultsDiv.style.display='none'; resultsDiv.innerHTML=''; return alert("Entrez un nom de lieu"); }
  const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=6&q=${encodeURIComponent(q)}&addressdetails=1&accept-language=fr`;
  try{
    resultsDiv.style.display='block';
    resultsDiv.innerHTML = '<div style="padding:10px;color:#666;font-size:13px;">üîé Recherche...</div>';
    const res = await fetch(url, { headers:{ 'Accept':'application/json' }});
    if(!res.ok) throw new Error('HTTP '+res.status);
    const data = await res.json();
    if(!data || !data.length){ resultsDiv.innerHTML = '<div style="padding:10px;color:#666;font-size:13px;">Aucun r√©sultat.</div>'; return; }
    resultsDiv.innerHTML = '';
    data.forEach((place, idx) => {
      const display = place.display_name || (place.name || 'Lieu inconnu');
      const lat = parseFloat(place.lat), lon = parseFloat(place.lon);
      const type = place.type || place.class || '';
      const item = document.createElement('div');
      item.className = 'result';
      item.style.padding='8px';
      item.style.borderBottom='1px solid rgba(0,0,0,0.06)';
      item.innerHTML = `<div style="font-size:13px">${display}</div><div style="font-size:12px;color:#666">${type}</div>`;
      item.onclick = () => {
        map.setView([lat,lon], Math.max(13, place.zoom?+place.zoom:14));
        searchMarkerGroup.clearLayers();
        L.marker([lat,lon]).addTo(searchMarkerGroup).bindPopup(`<b>${display}</b>`).openPopup();
        resultsDiv.style.display='none'; resultsDiv.innerHTML='';
      };
      resultsDiv.appendChild(item);
    });
    // center on first
    const first = data[0];
    if(first){ map.setView([parseFloat(first.lat), parseFloat(first.lon)], Math.max(13, first.zoom?+first.zoom:14)); searchMarkerGroup.clearLayers(); L.marker([parseFloat(first.lat), parseFloat(first.lon)]).addTo(searchMarkerGroup).bindPopup(first.display_name||'').openPopup(); }
  } catch(err){
    console.error("searchLocation error:", err);
    resultsDiv.style.display='block';
    resultsDiv.innerHTML = `<div style="padding:10px;color:#900;font-size:13px;">Erreur de recherche (${err.message})</div>`;
  }
}
document.getElementById('searchInput').addEventListener('keydown', function(e){ if(e.key==='Enter'){ e.preventDefault(); searchLocation(); } });
map.on('click', () => { const resultsDiv=document.getElementById('searchResults'); if(resultsDiv){ resultsDiv.style.display='none'; resultsDiv.innerHTML=''; } });
document.addEventListener('click', (e) => { const topBar=document.querySelector('.top-bar'); const resultsDiv=document.getElementById('searchResults'); if(!topBar.contains(e.target) && resultsDiv){ resultsDiv.style.display='none'; resultsDiv.innerHTML=''; } });

/* --------------------- IMPORT/EXPORT IBP FORM SUBMIT (conserve comportement) --------------------- */
$("#formuploadajax").on("submit", function(e){
  e.preventDefault();
  var formData = new FormData(this);
  $.ajax({
    url: "https://www.ibpindex.com/api/",
    type: "post",
    dataType: "json",
    data: formData,
    cache: false,
    contentType: false,
    processData: false
  }).done(function(javascript_json){
    try {
      let weobtain = `<h3>R√©sultat IBP HKG</h3><b>R√©f√©rence :</b> ${javascript_json.reference}<br><b>Fichier :</b> ${javascript_json.filename}<br><br>ü•æ <b>IBP Randonn√©e (HKG) :</b> <span style="font-size:22px;color:${'#2a66c7'}">${javascript_json.hiking.ibp}</span><br><br>‚¨ÜÔ∏è <b>D√©nivel√© cumul√© :</b> ${javascript_json.hiking.accuclimb} m<br>‚è± <b>Temps arr√™t :</b> ${javascript_json.hiking.totalstoptime} s`;
      document.getElementById("obtain").innerHTML = weobtain;
    } catch(err){
      document.getElementById("obtain").innerHTML = "‚úÖ R√©sultat re√ßu (format inattendu).";
      console.error("IBP parse error:", err, javascript_json);
    }
  }).fail(function(){ document.getElementById("obtain").innerHTML = "‚ùå Erreur lors du calcul IBP."; });
});

/* --------------------- HELPERS: tooltip / toast --------------------- */
function showTooltip(text, duration=1600){
  const t = document.getElementById('mobileTooltip');
  t.innerText = text;
  t.style.display = 'block';
  t.style.left = '50%';
  t.style.transform = 'translateX(-50%)';
  setTimeout(()=>{ t.style.display = 'none'; }, duration);
}

/* --------------------- SAVE / LOAD ROUTE (localStorage) --------------------- */
const STORAGE_KEY = "traceur_manual_route_v1";
function saveRouteLocal(){
  try{
    if(!manualRouteCoords || !manualRouteCoords.length){ localStorage.removeItem(STORAGE_KEY); return; }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(manualRouteCoords));
  } catch(e){ console.warn("saveRouteLocal fail:",e); }
}
function loadRouteLocal(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return false;
    manualRouteCoords = JSON.parse(raw);
    if(!manualRouteCoords || !manualRouteCoords.length) return false;
    const latlngs = manualRouteCoords.map(c=>[c[0],c[1]]);
    routeLayer.clearLayers();
    L.polyline(latlngs, { color:"green", weight:4 }).addTo(routeLayer);
    createEditableMarkersFromCoords(latlngs);
    drawElevation(manualRouteCoords.map(c=>c[2]||0), latlngs);
    map.fitBounds(latlngs, { padding:[20,20] });
    return true;
  } catch(e){ console.warn("loadRouteLocal fail:",e); return false; }
}
function clearSavedRoute(){ try{ localStorage.removeItem(STORAGE_KEY); }catch(e){} }

/* --------------------- CENTER GPS --------------------- */
function centerGPS(){ if(gpsMarker) map.setView(gpsMarker.getLatLng(),14); }

/* --------------------- UI small functions --------------------- */
function toggleInfoPanel(){
  const panel = document.querySelector('.container');
  if(!panel) return;
  panel.classList.toggle('open');
  panel.classList.toggle('closed');
}
function closeStartupPopup(){ document.getElementById('startupPopup').style.display = 'none'; }

/* --------------------- INIT on load --------------------- */
window.addEventListener('load', () => {
  // show startup
  document.getElementById("startupPopup").style.display = "flex";
  // try to restore previously saved trace
  if(loadRouteLocal()){ showTooltip("Trace restaur√©e depuis la session pr√©c√©dente"); }
  console.log("Traceur charg√© (version rev).");
});

/* ==== DOCK AMOVIBLE (SWIPE DOWN) ‚Äî FIX LEAFLET MOBILE ==== */
(function enableDockSwipe(){

  const dock = document.querySelector('.leaflet-control.custom-panel');
  if(!dock) return;

  const handle = dock.querySelector('.icon-grid');
  if(!handle) return;

  let startY = 0;
  let deltaY = 0;

  handle.addEventListener('touchstart', e => {
    if(e.touches.length !== 1) return;
    startY = e.touches[0].clientY;
    deltaY = 0;
    e.stopPropagation();
  }, { passive:true });

  handle.addEventListener('touchmove', e => {
    if(!startY) return;
    deltaY = e.touches[0].clientY - startY;
    e.stopPropagation();
  }, { passive:true });

  handle.addEventListener('touchend', e => {
    if(Math.abs(deltaY) < 30) return;

    if(deltaY > 0){
      dock.classList.add('closed');   // swipe down
    } else {
      dock.classList.remove('closed'); // swipe up
    }

    startY = 0;
    deltaY = 0;
    e.stopPropagation();
  });

})();

document.querySelector('.dock-handle')?.addEventListener('click', () => {
  document.querySelector('.leaflet-control.custom-panel')?.classList.toggle('closed');
});
(function enableInfoHandle(){
  const panel = document.querySelector('.container');
  const handle = document.querySelector('.info-handle');
  if(!panel || !handle) return;

  // √©tat initial
  panel.classList.add('closed');

  handle.addEventListener('click', () => {
    panel.classList.toggle('open');
    panel.classList.toggle('closed');
  });
})();


</script>

</body>
</html>
