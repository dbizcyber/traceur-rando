<!DOCTYPE html>
<html lang="fr">
<!-- PWA -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#2a66c7">

<!-- iOS -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Traceur Rando">

<link rel="apple-touch-icon" href="icons/icon-192.png">

<head>
  <meta charset="utf-8">
<title>Traceur randonn√©e val6.5.2 -> 6.6 mobile - IBP - thunderforest</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
<script src="https://unpkg.com/togpx@0.5.0/togpx.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>

<style>
  /* ===== Base ===== */
  body { margin:0; font-family: Arial, sans-serif; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  #map { height: 100vh; }

body {
  overflow: hidden;
}


  #distance { font-size: 14px; margin: 8px 0; }
  #elevationChart { height: 160px !important; }

  /* ===== TOP BAR (Recherche + Import) ===== */
  .top-bar {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    z-index: 1400;
    background: rgba(0,0,0,0);
    padding: 6px 10px;
    border-radius: 20px;
    pointer-events: auto;
  }
  .top-bar * { pointer-events: auto; } /* assure l'interaction sur mobile */

  .top-bar input[type="text"],
  .top-bar input[type="search"],
  .top-bar input[type="file"] {
    background: rgba(255,255,255,0.95);
    border: none;
    border-radius: 12px;
    padding: 6px 10px;
    font-size: 14px;
    outline: none;
    height: 34px;
  }
  .top-bar input[type="text"],
  .top-bar input[type="search"] {
    width: 160px;
  }
  .top-bar input[type="file"] {
    width: 120px;
    padding: 6px 8px;
    font-size: 12px;
  }

  @media (max-width:420px) {
    .top-bar input[type="text"]{ width: 120px; }
  }

  /* ===== DOCK GPS FLOTTANT (unique, propre) ===== */
  /* ===== DOCK GPS FLOTTANT (unique, propre) ===== */
.leaflet-control.custom-panel {
  position: fixed !important;
  bottom: 14px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  justify-content: center;
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0;
  width: auto;
  z-index: 1500;
  pointer-events: auto;
}

/* Conteneur d'ic√¥nes : plus fluide et responsive.
   On retire le fond gris, on autorise le retour √† la ligne
   et on limite la largeur pour √©viter le d√©bordement. */
.icon-grid {
  display: flex;
  flex-wrap: wrap;               /* permet de passer √† la ligne si l'espace manque */
  gap: 8px;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
  padding: 6px;
  background: transparent;       /* suppression du fond gris */
  border-radius: 28px;
  max-width: 94vw;               /* ne d√©passe jamais l'√©cran (quelques px de marge) */
  box-sizing: border-box;
  -webkit-overflow-scrolling: touch;
  overflow: hidden;              /* √©vite les d√©bordements visuels */
}

/* Boutons : tailles fluides avec clamp pour rester lisibles,
   taille minimale/ max contr√¥l√©es ; suppression des gros fonds opaques. */
.icon-btn {
  width: clamp(30px, 8vw, 44px);   /* min 30px, max 44px, s'adapte selon l'√©cran */
  height: clamp(30px, 8vw, 44px);
  border-radius: 50%;
  border: none;
  background: rgba(0,0,0,0.18);    /* si vous voulez totalement transparent => transparent */
  color: #fff;
  font-size: clamp(14px, 4.2vw, 18px);
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.18);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  flex: 0 0 auto;                  /* emp√™che les boutons d'√©tirer leur largeur */
  min-width: 0;
}

/* variantes */
.icon-btn.secondary { background: rgba(0,0,0,0.12); }
.icon-btn.recording { background: rgba(180,0,0,0.65); animation: pulse 1.2s infinite; }

.icon-btn:active { transform: scale(0.92); }

/* ajustements pour tr√®s petits √©crans : r√©duire gaps et padding */
@media (max-width:420px){
  .icon-grid { gap: 6px; padding: 4px; max-width: 98vw; }
  .icon-btn { width: clamp(28px, 9vw, 40px); height: clamp(28px, 9vw, 40px); font-size: clamp(13px, 4.8vw, 16px); }
  .top-bar { top: 8px; padding: 6px 8px; }
}

/* si vous pr√©f√©rez un d√©filement horizontal au lieu du wrap sur t√©l√©phones,
   remplacez .icon-grid rules par ces options (d√©commentez et testez si vous pr√©f√©rez) :

.icon-grid {
  display:flex;
  gap:8px;
  overflow-x:auto;
  white-space:nowrap;
  -webkit-overflow-scrolling:touch;
  padding:6px;
  background:transparent;
}
*/


  /* ===== FULLSCREEN MODE ===== */
  body.fullscreen #map { height: 100vh !important; }
  /* masquer seulement la zone container (infos/profil) mais laisser le dock et la top-bar visibles */
  body.fullscreen .container { display: none !important; }

  /* ===== TOOLTIP MOBILE ===== */
  .tooltip-mobile {
    position:absolute;
    background:rgba(0,0,0,0.85);
    color:#fff;
    padding:6px 8px;
    border-radius:6px;
    font-size:12px;
    z-index:2000;
    display:none;
    pointer-events:none;
  }

  /* petit ajustement responsive */
  @media (max-width:420px){
    .icon-btn{ width:30px; height:30px; font-size:14px; }
    .top-bar { top: 8px; padding: 6px 8px; }
  }
/* ===== PANNEAU INFOS (√âL√âVATION + IBP) ===== */

.container {
  position: fixed;
  bottom: -260px;          /* cach√© par d√©faut */
  left: 0;
  width: 100%;
  height: 260px;
  background: #111;
  color: white;
  z-index: 1400;
  transition: bottom 0.3s ease;
  overflow-y: auto;
  padding: 10px;
}

/* quand ouvert */
.container.open {
  bottom: 0;
}

/* bouton d‚Äôouverture */
.info-toggle {
  position: fixed;
  bottom: 60px;
  left: 10px;
  z-index: 1500;
  background: #2a66c7;
  color: white;
  border: none;
  border-radius: 20px;
  padding: 8px 14px;
  font-size: 14px;
}
.leaflet-container {
  touch-action: pan-x pan-y !important;
}

</style>
</head>
<body>

  <!-- Carte -->
  <div id="map"></div>
  <button class="info-toggle" onclick="toggleInfoPanel()">
  üìä Infos
</button>


  <!-- Barre du haut : recherche + import (hors panel Leaflet) -->
  <div class="top-bar" role="region" aria-label="recherche et import gpx">
    <input id="searchInput" type="search" placeholder="üîç Rechercher un lieu" aria-label="Rechercher un lieu">
    <input id="importFile" type="file" accept=".gpx,application/gpx+xml,application/json,application/geo+json" aria-label="Importer GPX">
  </div>

  <!-- Infos / profil / r√©sultat -->
  <div class="container" style="padding:10px;">
    <div id="distance"></div>
    <canvas id="elevationChart"></canvas>

    <form id="formuploadajax" enctype="multipart/form-data" style="display:none;">
      <input type="hidden" name="key" value="ifwh7wlwykzixzxcg6rb">
      <input type="hidden" name="type" value="hiking">
      <input type="file" id="ibpFile" name="file" accept=".gpx">
    </form>
    <div id="obtain"></div>
  </div>

  <div id="mobileTooltip" class="tooltip-mobile"></div>

  <!-- Bouton plein √©cran (supprim√©) -->


<script>
/* --------------------- CONFIG --------------------- */
const ORS_KEY = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImI4YjFjZDdiMTkyZWZmYTc0N2IyNjQ3MWMxNWJkYzAwMWNiMjI1NGZjNmYyMTI5MDgwN2ZmYzgyIiwiaCI6Im11cm11cjY0In0=";
const ORS_URL = "https://api.openrouteservice.org/v2/directions/foot-hiking/geojson";

/* --------------------- CARTE --------------------- */
const map = L.map('map').setView([46.8,2.2],6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

/* --------------------- COUCHES / ETATS --------------------- */
let markers = L.layerGroup().addTo(map);
let routeLayer = L.layerGroup().addTo(map);
let straightLineLayer = L.layerGroup().addTo(map);
let manualPoints = [];
let manualRouteCoords = [];

let A = null, B = null;
let markerA = null, markerB = null;
let straightLine = null;

const thunderforestTrails = L.tileLayer(
  "https://tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey=0ffff5950d8a4019bcede9aaeeecb57f",
  { maxZoom: 22, attribution: "Maps ¬© Thunderforest, Data ¬© OpenStreetMap contributors" }
);
let thunderforestVisible = false;

const hikingTrailsLayer = L.tileLayer("https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png",{ maxZoom:18, opacity:0.9, attribution:"¬© Waymarked Trails / OSM" });
let hikingVisible = false;

/* --------------------- PANEL (ic√¥nes) - position coh√©rente bottomleft --------------------- */
const panel = L.control({ position: 'bottomleft' });
panel.onAdd = function(){
  const div = L.DomUtil.create('div','leaflet-control custom-panel');
  div.innerHTML = `
    <div class="icon-grid" role="toolbar" aria-label="menu actions">
      <button class="icon-btn" onclick="searchLocation()" title="Rechercher">üîç</button>
      <button class="icon-btn" onclick="setPointA()" title="Point A">üÖ∞Ô∏è</button>
      <button class="icon-btn" onclick="setPointB()" title="Point B">üÖ±Ô∏è</button>
      <button class="icon-btn" onclick="drawStraightLine()" title="Ligne A‚ÜíB">üìè</button>

      <button class="icon-btn secondary" onclick="removeLastPoint()" title="Annuler dernier point">‚Ü©Ô∏è</button>
      <button class="icon-btn secondary" onclick="clearAll()" title="Effacer tout">üóëÔ∏è</button>

      <button class="icon-btn" onclick="exportGPX()" title="Exporter GPX">üíæ</button>
      <button class="icon-btn" onclick="toggleHikingTrails()" title="Afficher/masquer sentiers">ü•æ</button>

      <button class="icon-btn" onclick="centerGPS()" title="Recentrer GPS">üìç</button>
      <button class="icon-btn" id="recBtn" onclick="toggleAutoRecording()" title="Enregistrement GPS">‚ñ∂Ô∏è</button>
      <button class="icon-btn" onclick="toggleThunderforestTrails()" title="Sentiers Thunderforest">üå≤</button>
    </div>
  `;
  // laisser la possibilit√© d'interagir sur les inputs ext√©rieurs si pr√©sents
  L.DomEvent.disableClickPropagation(div);
  return div;
};
panel.addTo(map);

/* --------------------- GPS (pointeur rouge) --------------------- */
let gpsMarker = null;
if(navigator.geolocation){
  navigator.geolocation.watchPosition(pos=>{
    const latlng = [pos.coords.latitude, pos.coords.longitude];
    const redIcon = L.icon({ iconUrl: "https://upload.wikimedia.org/wikipedia/commons/e/ec/RedDot.svg", iconSize:[14,14], iconAnchor:[7,7]});
    if(!gpsMarker){
      gpsMarker = L.marker(latlng,{icon:redIcon}).addTo(map);
      map.setView(latlng, 12);
    } else gpsMarker.setLatLng(latlng);
  }, err=>console.warn("GPS:", err), { enableHighAccuracy:true });
}

/* --------------------- UTILITAIRES ELEVATION & DISTANCE --------------------- */
function smoothArray(data, alpha=0.22){
  if(!data.length) return data;
  const out = new Array(data.length);
  out[0] = data[0];
  for(let i=1;i<data.length;i++) out[i] = out[i-1]*(1-alpha) + data[i]*alpha;
  out[out.length-1] = data[data.length-1];
  return out;
}
function computeElevationGain(elev){
  let up=0, down=0;
  for(let i=1;i<elev.length;i++){ const d = elev[i]-elev[i-1]; if(d>0) up+=d; else down+=Math.abs(d); }
  return {positive:Math.round(up), negative:Math.round(down)};
}
function computeMinMax(elev){ if(!elev.length) return {min:0,max:0}; return {min:Math.round(Math.min(...elev)), max:Math.round(Math.max(...elev))}; }
function computeTotalDistanceLatLngs(latlngs){ if(!latlngs.length) return 0; let tot=0; for(let i=1;i<latlngs.length;i++) tot+=L.latLng(latlngs[i-1][0],latlngs[i-1][1]).distanceTo(L.latLng(latlngs[i][0],latlngs[i][1])); return tot; }
function computeCumulativeDistances(latlngs){ let arr=[0], tot=0; for(let i=1;i<latlngs.length;i++){ tot+=L.latLng(latlngs[i-1][0],latlngs[i-1][1]).distanceTo(L.latLng(latlngs[i][0],latlngs[i][1])); arr.push((tot/1000).toFixed(3)); } return arr; }

/* --------------------- CHART PROFIL --------------------- */
let elevationChart = null;
function drawElevation(elevations, latlngs=[]){
  const smooth = smoothArray(elevations.map(e=>Math.round(e||0)), 0.22);
  const gain = computeElevationGain(smooth);
  const mm = computeMinMax(smooth);
  const cumulative = latlngs.length ? computeCumulativeDistances(latlngs) : smooth.map((_,i)=>i);

  const ctx = document.getElementById('elevationChart').getContext('2d');
  if(elevationChart) elevationChart.destroy();
  elevationChart = new Chart(ctx, {
    type:'line',
    data:{ labels:cumulative, datasets:[{ label:'Altitude (m)', data:smooth, borderWidth:2, fill:false, tension:0.25, pointRadius:0 }]},
    options:{ responsive:true, maintainAspectRatio:false, scales:{ x:{ title:{display:true,text:"Distance (km)"}}, y:{ title:{display:true,text:"Altitude (m)"} } } }
  });

  const totalDistance = latlngs.length ? (computeTotalDistanceLatLngs(latlngs)/1000).toFixed(2) : "0.00";
  document.getElementById('distance').innerHTML = `üìè <b>Distance totale :</b> ${totalDistance} km<br>‚¨ÜÔ∏è <b>D+ :</b> ${gain.positive} m &nbsp; ‚¨áÔ∏è <b>D- :</b> ${gain.negative} m<br>üîª <b>Min :</b> ${mm.min} m | üî∫ <b>Max :</b> ${mm.max} m`;
}

/* --------------------- REBUILD MULTIPOINTS (UN SEUL APPEL ORS) --------------------- */
async function rebuildManualRouteFromPoints(){
  routeLayer.clearLayers();
  manualRouteCoords = [];

  if(manualPoints.length < 2){ drawElevation([],[]); return; }

  try {
    const res = await fetch(ORS_URL, {
      method: "POST",
      headers: { "Authorization": ORS_KEY, "Content-Type": "application/json" },
      body: JSON.stringify({ coordinates: manualPoints, elevation:true, instructions:false, preference:"recommended" })
    });

    if(!res.ok) throw new Error("ORS HTTP " + res.status);
    const data = await res.json();
    if(!data.features || !data.features.length) throw new Error("ORS: pas de g√©om√©trie");

    const coords = data.features[0].geometry.coordinates;
    coords.forEach(c => { manualRouteCoords.push([c[1], c[0], c[2] || 0]); });

    const latlngs = manualRouteCoords.map(c => [c[0], c[1]]);
    L.polyline(latlngs, { color:"green", weight:4, smoothFactor:1.2 }).addTo(routeLayer);

    drawElevation(manualRouteCoords.map(c=>c[2]||0), latlngs);
    refreshMarkers();
  } catch(err){
    console.error("Erreur ORS multipoints:", err);
    alert("Erreur ORS multipoints ‚Äî v√©rifie la cl√©/connexion (voir console).");
  }
}

/* --------------------- GESTION CLICS MAP POUR AJOUT POINTS --------------------- */
map.on('click', e => {
  manualPoints.push([e.latlng.lng, e.latlng.lat]);
  rebuildManualRouteFromPoints();
});

/* --------------------- A / B LIGNE DROITE --------------------- */
function setPointA(){
  map.once('click', e => {
    A = e.latlng;
    if(markerA) straightLineLayer.removeLayer(markerA);
    markerA = L.marker(A).addTo(straightLineLayer).bindPopup("A").openPopup();
  });
}
function setPointB(){
  map.once('click', e => {
    B = e.latlng;
    if(markerB) straightLineLayer.removeLayer(markerB);
    markerB = L.marker(B).addTo(straightLineLayer).bindPopup("B").openPopup();
  });
}
function drawStraightLine(){
  if(!A || !B) return alert("D√©finissez A et B avant de tracer la ligne droite.");
  if(straightLine) straightLineLayer.removeLayer(straightLine);
  straightLine = L.polyline([[A.lat,A.lng],[B.lat,B.lng]], { color:"red", weight:3, dashArray:"6,6" }).addTo(straightLineLayer);

  const dist = A.distanceTo(B)/1000;
  const prev = document.getElementById('distance').innerHTML || "";
  document.getElementById('distance').innerHTML = `üìè Ligne droite A‚ÜíB : <b>${dist.toFixed(2)} km</b><br>` + prev;
  map.fitBounds(L.latLngBounds([A,B]).pad(0.2));
}

/* --------------------- ORS ENTRE A ET B (OPTIONNEL) --------------------- */
async function computeRoute(){
  if(!A || !B) return alert("D√©finissez A et B pour calculer le trac√© r√©el ORS entre eux.");
  try {
    const res = await fetch(ORS_URL, {
      method:"POST",
      headers: { "Authorization": ORS_KEY, "Content-Type": "application/json" },
      body: JSON.stringify({ coordinates: [[A.lng,A.lat],[B.lng,B.lat]], elevation:true, instructions:false })
    });
    if(!res.ok) throw new Error("ORS HTTP " + res.status);
    const data = await res.json();
    const coords = data.features[0].geometry.coordinates.map(c=>[c[1],c[0]]);
    const elev = data.features[0].geometry.coordinates.map(c=>c[2]||0);
    L.polyline(coords, { color:"blue", weight:4 }).addTo(routeLayer);
    map.fitBounds(coords);
    drawElevation(elev, coords);
  } catch(err){ console.error("Erreur computeRoute:", err); alert("Erreur ORS computeRoute."); }
}

/* --------------------- IMPORT / EXPORT --------------------- */
document.getElementById('importFile').addEventListener('change', async (evt) => {
  const file = evt.target.files[0];
  if(!file) return;
  const text = await file.text();
  let geojson = null;
  try {
    if(file.name.toLowerCase().endsWith('.gpx')){
      const xml = new DOMParser().parseFromString(text, "application/xml");
      geojson = toGeoJSON.gpx(xml);
    } else geojson = JSON.parse(text);
  } catch(err){ return alert("Fichier invalide"); }

  manualPoints = [];
  manualRouteCoords = [];
  routeLayer.clearLayers();
  markers.clearLayers();

  let coords = [];
  (geojson.features || []).forEach(f => {
      if (!f.geometry) return;
      if (f.geometry.type === "LineString") coords.push(...f.geometry.coordinates);
      if (f.geometry.type === "MultiLineString") f.geometry.coordinates.forEach(seg => coords.push(...seg));
  });

  if (!coords.length) {
      return alert("Aucune trace exploitable trouv√©e dans ce fichier GPX");
  }

  coords.forEach(c => manualRouteCoords.push([c[1], c[0], c[2]||0]));
  L.polyline(manualRouteCoords.map(c=>[c[0],c[1]]), { color:"red", weight:2 }).addTo(routeLayer);

  const bounds = manualRouteCoords.map(c => [c[0], c[1]]);
  map.fitBounds(bounds, { padding: [20, 20] });

  drawElevation(manualRouteCoords.map(c=>c[2]||0), manualRouteCoords.map(c=>[c[0],c[1]]));
  manualPoints = [];

  document.getElementById('distance').innerHTML += "<br>üìÇ Trace import√©e";
});

/* export */
function exportGeoJSON(){
  if(!manualRouteCoords.length) return alert("Aucune trace √† exporter");
  const geo = { type:"FeatureCollection", features:[{ type:"Feature", geometry:{ type:"LineString", coordinates: manualRouteCoords.map(c=>[c[1],c[0],c[2]||0]) }, properties:{} }]};
  const blob = new Blob([JSON.stringify(geo)],{ type:"application/json" });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "trace.geojson"; a.click();
}

function exportGPX(){
  if(manualRouteCoords.length < 2) return alert("Aucune trace compl√®te √† exporter");
  const geo = { type:"FeatureCollection", features:[{ type:"Feature", geometry:{ type:"LineString", coordinates: manualRouteCoords.map(c=>[c[1],c[0],c[2]||0]) }, properties:{ name:"Trace compl√®te ORS" } }]};
  const gpx = togpx(geo);
  const blob = new Blob([gpx], { type:"application/gpx+xml" });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "trace_complete.gpx"; a.click();

  try {
    const file = new File([blob],"trace_complete.gpx",{ type:"application/gpx+xml" });
    const dt = new DataTransfer(); dt.items.add(file);
    document.getElementById('ibpFile').files = dt.files;
    document.getElementById('formuploadajax').dispatchEvent(new Event('submit', { bubbles:true, cancelable:true }));
    document.getElementById('obtain').innerHTML = "‚è≥ Calcul IBP en cours (GPX COMPLET envoy√©)...";
  } catch(err){ console.error("Erreur injection IBP:", err); }
}

/* --------------------- ANNULER / EFFACER --------------------- */
function refreshMarkers(){
  markers.clearLayers();
  manualPoints.forEach((p, idx) => {
    const m = L.circleMarker([p[1], p[0]], { radius: 6, color: "#0066ff", weight: 2, fillColor: "#3399ff", fillOpacity: 0.9 }).addTo(markers);
    m.on('contextmenu', () => { manualPoints.splice(idx,1); rebuildManualRouteFromPoints(); refreshMarkers(); });
  });
}
function removeLastPoint(){ if(!manualPoints.length) return; manualPoints.pop(); rebuildManualRouteFromPoints(); refreshMarkers(); }
function clearAll(){
  manualPoints=[]; manualRouteCoords=[]; routeLayer.clearLayers(); markers.clearLayers();
  if(markerA){ straightLineLayer.removeLayer(markerA); markerA=null; A=null; }
  if(markerB){ straightLineLayer.removeLayer(markerB); markerB=null; B=null; }
  if(straightLine){ straightLineLayer.removeLayer(straightLine); straightLine=null; }
  document.getElementById('distance').innerHTML="";
  if(elevationChart) elevationChart.destroy();
}

/* --------------------- FORMULAIRE IBP AJAX --------------------- */
$("#formuploadajax").on("submit", function(e){
  e.preventDefault();
  var formData = new FormData(this);
  $.ajax({
    url: "https://www.ibpindex.com/api/",
    type: "post",
    dataType: "json",
    data: formData,
    cache: false,
    contentType: false,
    processData: false
  }).done(function(javascript_json){
    let weobtain = `<h3>R√©sultat IBP HKG</h3><b>R√©f√©rence :</b> ${javascript_json.reference}<br><b>Fichier :</b> ${javascript_json.filename}<br><br>ü•æ <b>IBP Randonn√©e (HKG) :</b> <span style="font-size:22px;color:#2a66c7">${javascript_json.hiking.ibp}</span><br><br>‚¨ÜÔ∏è <b>D√©nivel√© cumul√© :</b> ${javascript_json.hiking.accuclimb} m<br>‚è± <b>Temps arr√™t :</b> ${javascript_json.hiking.totalstoptime} s`;
    document.getElementById("obtain").innerHTML = weobtain;
  }).fail(function(){ document.getElementById("obtain").innerHTML = "‚ùå Erreur lors du calcul IBP."; });
});

/* --------------------- SENTIERS ON/OFF --------------------- */
function toggleHikingTrails(){ if(hikingVisible) map.removeLayer(hikingTrailsLayer); else hikingTrailsLayer.addTo(map); hikingVisible = !hikingVisible; }
function toggleThunderforestTrails(){
  if (thunderforestVisible) map.removeLayer(thunderforestTrails); else thunderforestTrails.addTo(map);
  thunderforestVisible = !thunderforestVisible;
}

/* --------------------- RECHERCHE LIEU (Nominatim) --------------------- */
async function searchLocation(){
  const q = document.getElementById('searchInput').value.trim();
  if(!q) return alert("Entrez un nom de lieu");
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`;
  try{
    const res = await fetch(url, { headers: { "Accept":"application/json", "User-Agent":"rando-app" }});
    const data = await res.json();
    if(!data.length) return alert("Lieu introuvable");
    const lat = parseFloat(data[0].lat), lon = parseFloat(data[0].lon);
    map.setView([lat,lon],14);
    L.marker([lat,lon]).addTo(map).bindPopup(data[0].display_name).openPopup();
  } catch(err){ console.error("searchLocation error:", err); alert("Erreur de recherche"); }
}

/* --------------------- IC√îNES AVANCEES: GPS / REC --------------------- */
function centerGPS(){ if(gpsMarker) map.setView(gpsMarker.getLatLng(),14); }

let gpsTracking=false, recordedTrace=[];
function toggleAutoRecording(){
  gpsTracking = !gpsTracking;
  const btn = document.getElementById('recBtn');
  if(!btn) return;
  if(gpsTracking){ recordedTrace=[]; btn.classList.add('recording'); btn.innerHTML='‚èπÔ∏è'; }
  else { btn.classList.remove('recording'); btn.innerHTML='‚ñ∂Ô∏è'; if(recordedTrace.length>2){ manualRouteCoords = recordedTrace.map(p=>[p.lat,p.lng,p.ele||0]); routeLayer.clearLayers(); L.polyline(recordedTrace.map(p=>[p.lat,p.lng]),{color:"green",weight:4}).addTo(routeLayer); drawElevation(recordedTrace.map(p=>p.ele||0), recordedTrace.map(p=>[p.lat,p.lng])); } }
}

/* enregistrer positions GPS quand recording actif */
if(navigator.geolocation){
  navigator.geolocation.watchPosition(p=>{
    if(gpsTracking) recordedTrace.push({ lat:p.coords.latitude, lng:p.coords.longitude, ele:p.coords.altitude||0 });
  }, err=>{}, { enableHighAccuracy:true });
}

/* --------------------- PLEIN ECRAN MOBILE (bouton supprim√© DOM) --------------------- */

/* --------------------- PROTECTION: si on avait tent√© de d√©sactiver la saisie dans un panel (ancien code) */
(function(){
  // autorise la saisie dans le champ recherche (certaines anciennes versions tentaient de l'interdire)
  const input = document.getElementById('searchInput');
  if(input){
    input.addEventListener('mousedown', e => e.stopPropagation());
    input.addEventListener('touchstart', e => e.stopPropagation());
  }
})();

/* --------------------- FIN --------------------- */
console.log("Traceur charg√©. Dock + top-bar actifs.");
function toggleInfoPanel(){
  const panel = document.querySelector('.container');
  panel.classList.toggle('open');
}

</script>
<script>
  const input = document.getElementById('searchInput');

  // ‚úÖ Validation avec la touche Entr√©e (CR)
  input.addEventListener('keydown', function (e) {
    if (e.key === 'Enter' && !e.isComposing) {
      e.preventDefault();
      const query = input.value.trim();
      if (!query) return;
      searchWithNominatim(query);
    }
  });

  // ‚úÖ Recherche r√©elle avec Nominatim + centrage carte
  function searchWithNominatim(query) {
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;

    fetch(url)
      .then(res => res.json())
      .then(results => {
        if (!results || results.length === 0) {
          alert("Aucun r√©sultat trouv√©");
          return;
        }

        const lat = parseFloat(results[0].lat);
        const lon = parseFloat(results[0].lon);

        // ‚úÖ Centre la carte (‚ö†Ô∏è votre carte doit s'appeler "map")
        map.setView([lat, lon], 14);

        // ‚úÖ Supprime l‚Äôancien marqueur si pr√©sent
        if (window.searchMarker) {
          map.removeLayer(window.searchMarker);
        }

        // ‚úÖ Nouveau marqueur
        window.searchMarker = L.marker([lat, lon]).addTo(map)
          .bindPopup(results[0].display_name)
          .openPopup();
      })
      .catch(err => {
        console.error("Erreur Nominatim :", err);
        alert("Erreur lors de la recherche");
      });
  }
</script>

<script>
  const searchInput = document.getElementById('searchInput');

  /* ‚úÖ Ferme le clavier d√®s qu'on touche la carte */
  map.getContainer().addEventListener('touchstart', function () {
    searchInput.blur();
  });

  map.getContainer().addEventListener('mousedown', function () {
    searchInput.blur();
  });

  /* ‚úÖ Corrige la perte de contr√¥le tactile apr√®s recherche */
  function restoreMapFocus() {
    setTimeout(function () {
      map.invalidateSize();
    }, 400);
  }

  /* ‚úÖ On modifie DIRECTEMENT votre fonction Nominatim existante */
  const oldSearch = searchWithNominatim;

  searchWithNominatim = function(query) {
    oldSearch(query);
    searchInput.blur();      // ferme le clavier
    restoreMapFocus();       // restaure les √©v√©nements tactiles
  };

  /* ‚úÖ Emp√™che l'input de voler le scroll √† la carte */
  searchInput.addEventListener('touchmove', function(e) {
    e.stopPropagation();
  });
</script>



</body>
</html>